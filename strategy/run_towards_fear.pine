//@version=4



// -------------------------------------------------------------------------- //



strategy(title="RTF DEV Strategy", overlay=true, default_qty_type=strategy.percent_of_equity, default_qty_value=5, initial_capital=1000)



// -------------------------------------------------------------------------- //



bbl = 26  //bbl = input(title="BBI Band Length",    type=input.integer, defval=26,   minval=1,    step=1  )
bbs = 2   //bbs = input(title="BBI Band Stddev",    type=input.float,   defval=2.00, minval=0.1,  step=0.1)
bpp = 20  //bpp = input(title="BBI Pivot Point",    type=input.float,   defval=20,   minval=0.01, step=1  )
prb = 10 // prb = input(title="PAI Recent Bar",     type=input.integer, defval=10,     minval=1,      step=1  )



// -------------------------------------------------------------------------- //



rlt = input(title="RTF Loss Tolerance", type=input.float,   defval=2.0,    minval=0.1,     step=0.1    )
rpb = input(title="RTF Pause Bar",      type=input.integer, defval=1,     minval=1,        step=1      )
rtp = input(title="RTF Take Profit",    type=input.float,   defval=0.1,    minval=0.1,     step=0.1    )
sst = input(title="SAR Start",          type=input.float,   defval=0.02,   minval=0.01,    step=1      )
sin = input(title="SAR Increment",      type=input.float,   defval=0.0002, minval=0.00001, step=0.00001)
sma = input(title="SAR Maximum",        type=input.float,   defval=0.2,    minval=0.01,    step=1      )



// -------------------------------------------------------------------------- //



var HR = #d32f2f // Hex Red. The red color for our color scheme indicating short trades.
var HG = #388e3c // Hex Green. The green color for our color scheme indicating long trades.



// -------------------------------------------------------------------------- //



// new_psi returns parabolic SAR indicators for short and long trends.
//
//     sta    0.02
//     inc    0.0003
//     max    0.2
//
new_psi(sta, inc, max) =>
    dir = sar(sta, inc, max) < close ? 1 : -1

    sho = dir == -1 and dir[1] == 1 // Short direction indicator.
    lon = dir == 1 and dir[1] == -1 // Long direction indicator.
    cha = dir != dir[1]             // Change direction indicator.

    [sho, lon, cha]

new_psh() =>
    [sho, lon, cha] = new_psi(sst, sin, sma)

    sho

new_plo() =>
    [sho, lon, cha] = new_psi(sst, sin, sma)

    lon



// -------------------------------------------------------------------------- //



var OS = "OS" // Open Short. The signal to start a short trade.
var CS = "CS" // Close Short. The signal to end a short trade.
var OL = "OL" // Open Long. The signal to start a long trade.
var CL = "CL" // Close Long. The signal to end a long trade.

var DS = "DS" // Direction Short. Trading to win from falling prices.
var DL = "DL" // Direction Long. Trading to win from rising prices.

var FP = "FP" // First Price. The entry price of our current trade.
var LP = "LP" // Last Price. The exit price of our current trade.



// -------------------------------------------------------------------------- //



// Current Cycle. The cycle of the current trade. Either OS, CS, OL or CL.
var CC = array.new_string(4, "")

emp_ccc() =>
    nos = array.get(CC, 0) == ""
    ncs = array.get(CC, 1) == ""
    nol = array.get(CC, 2) == ""
    ncl = array.get(CC, 3) == ""

    nos and ncs and nol and ncl

has_ccc(v) =>
    has = false

    if v == OS
        has := array.get(CC, 0) == OS
    if v == CS
        has := array.get(CC, 1) == CS
    if v == OL
        has := array.get(CC, 2) == OL
    if v == CL
        has := array.get(CC, 3) == CL

    has

onl_ccc(v) =>
    has = false

    if v == OS
        has := array.get(CC, 0) == OS and array.get(CC, 1) == "" and array.get(CC, 2) == "" and array.get(CC, 3) == ""
    if v == CS
        has := array.get(CC, 0) == "" and array.get(CC, 1) == CS and array.get(CC, 2) == "" and array.get(CC, 3) == ""
    if v == OL
        has := array.get(CC, 0) == "" and array.get(CC, 1) == "" and array.get(CC, 2) == OL and array.get(CC, 3) == ""
    if v == CL
        has := array.get(CC, 0) == "" and array.get(CC, 1) == "" and array.get(CC, 2) == "" and array.get(CC, 3) == CL

    has

rem_ccc(v) =>
    if v == OS
        array.set(CC, 0, "")
    if v == CS
        array.set(CC, 1, "")
    if v == OL
        array.set(CC, 2, "")
    if v == CL
        array.set(CC, 3, "")

set_ccc(v) =>
    if v == OS
        array.set(CC, 0, v)
    if v == CS
        array.set(CC, 1, v)
    if v == OL
        array.set(CC, 2, v)
    if v == CL
        array.set(CC, 3, v)



// -------------------------------------------------------------------------- //



// Debug Flag. Only used for development. In complex decision trees we can print
// labels based on the position the global was modified. This can help a great
// deal figuring out why a certain trade was made.
var DF = array.new_string(8, "")

has_cdf(v) =>
    has = false

    if v == "1"
        has := array.get(DF, 0) != ""
    if v == "2"
        has := array.get(DF, 1) != ""
    if v == "3"
        has := array.get(DF, 2) != ""
    if v == "4"
        has := array.get(DF, 3) != ""
    if v == "5"
        has := array.get(DF, 4) != ""
    if v == "6"
        has := array.get(DF, 5) != ""
    if v == "7"
        has := array.get(DF, 6) != ""
    if v == "8"
        has := array.get(DF, 7) != ""

    has

set_cdf(v) =>
    if v == "1"
        array.set(DF, 0, v)
    if v == "2"
        array.set(DF, 1, v)
    if v == "3"
        array.set(DF, 2, v)
    if v == "4"
        array.set(DF, 3, v)
    if v == "5"
        array.set(DF, 4, v)
    if v == "6"
        array.set(DF, 5, v)
    if v == "7"
        array.set(DF, 6, v)
    if v == "8"
        array.set(DF, 7, v)

// Note that we need to clear the array's content in order to work with a fresh
// copy on each bar when the script is executed again.
array.fill(DF, "")



// -------------------------------------------------------------------------- //



// Failure Count.
var FC = array.new_int(1, 0)

get_cfc() =>
    array.get(FC, 0)

inc_cfc() =>
    array.set(FC, 0, array.get(FC, 0) + 1)

res_cfc() =>
    array.set(FC, 0, 0)



// -------------------------------------------------------------------------- //



// Pause Count.
var PC = array.new_int(1, 0)

get_cpc() =>
    array.get(PC, 0)

inc_cpc() =>
    array.set(PC, 0, array.get(PC, 0) + 1)

res_cpc() =>
    array.set(PC, 0, 0)



// -------------------------------------------------------------------------- //



// Preferred Direction.
var PD = array.new_string(1, "")

has_cpd(v) =>
    has = false

    if v == DS
        has := array.get(PD, 0) == DS
    if v == DL
        has := array.get(PD, 0) == DL

    has

ini_cpd() =>
    [sho, lon, cha] = new_psi(sst, sin, sma)

    if sho
        array.set(PD, 0, DS)

    if lon
        array.set(PD, 0, DL)

set_cpd(v) =>
    if v == DS
        array.set(PD, 0, DS)
    if v == DL
        array.set(PD, 0, DL)

ini_cpd()



// -------------------------------------------------------------------------- //



// Trade Price. The entry price and exit price of our current trade. Based on
// these prices and their delta we decide when to take profit and when to move
// on.
var TP = array.new_float(2, 0.0)

get_ctp(v) =>
    val = 0.0

    if v == FP
        val := array.get(TP, 0)
    if v == LP
        val := array.get(TP, 1)

    val

// gre_ctp returns the trade price delta for long directional trades. If the
// result is greater zero it means the long trade made profit.
gre_ctp() =>
    array.get(TP, 1) - array.get(TP, 0)

// les_ctp returns the trade price delta for short directional trades. If the
// result is greater zero it means the short trade made profit.
les_ctp() =>
    array.get(TP, 0) - array.get(TP, 1)

set_ctp(v) =>
    if v == FP
        array.set(TP, 0, close)
    if v == LP
        array.set(TP, 1, close)



// -------------------------------------------------------------------------- //



// new_per calculates the percentage of a fraction based on the given absolute
// value.
//
//     new_per(500, 5) => 1
//
new_per(abs, fra) =>
    fra * 100 / abs



// -------------------------------------------------------------------------- //



// new_bbu returns the upper bollinger band based on the length given by bbl and
// the standard deviation given by bbs. Here bbu means bollinger band upper.
new_bbu(src, bbl, bbs) =>
    sma(src, bbl) + bbs * stdev(src, bbl)

new_bbi(src, bbl, bbs) =>
    bbu = new_bbu(src, bbl, bbs)

    cou = 0
    bac = 8

    for i = 0 to bac
        cou := high[i] > bbu[i] and bbu[i] > low[i] ? cou + 1 : cou

    new_per(bac, cou) > bpp and not (high[0] > bbu[0] and bbu[0] > low[0])



// -------------------------------------------------------------------------- //



// new_rsb returns the relative strength indicator for the current bar, based on
// the running moving average. Here rsb means relative strength bar.
new_rsb(src, rsl) =>
    upw = rma( max(change(src), 0), rsl)
    dow = rma(-min(change(src), 0), rsl)

    dow == 0 ? 100 : upw == 0 ? 0 : 100 - (100 / (1 + upw / dow))

// new_rsi returns the relative strength indicator for overbought price peaks.
new_rsi(src) =>
    one = new_rsb(src, 120)[1] < 57 and new_rsb(src, 120)[0] > 57
    two = new_rsb(src, 50 )[1] < 65 and new_rsb(src, 50 )[0] > 65
    thr = new_rsb(src, 30 )[1] < 70 and new_rsb(src, 30 )[0] > 70
    fou = new_rsb(src, 17 )[1] < 63 and new_rsb(src, 17 )[0] > 63

    one or two or thr or fou



// -------------------------------------------------------------------------- //



// new_hpi returns a high price indicator for the most recent bars since prb.
// Here hpi means high price indicator.
new_hpi(prb) =>
    highest(close, prb) == close

// new_lpi returns a low price indicator for the most recent bars since prb.
// Here lpi means low price indicator.
new_lpi(prb) =>
    lowest(close, prb) == close



// -------------------------------------------------------------------------- //



// new_dci returns a direction change indicator. If we go PSAR indicated from
// short to long or from long to short new_dci returns true.
new_dci() =>
    [sho, lon, cha] = new_psi(sst, sin, sma)

    cha



// -------------------------------------------------------------------------- //



// new_lfs returns a signal for short trades having made a loss.
new_lfs() =>
    hdl = has_cpd(DL)
    los = 100 - new_per(high, get_ctp(FP)) >= rlt

    hdl or los

// new_lfl returns a signal for long trades having made a loss.
new_lfl() =>
    hds = has_cpd(DS)
    los = 100 - new_per(get_ctp(FP), low) >= rlt

    hds or los



// -------------------------------------------------------------------------- //



// new_pfs returns a signal for short trades having made a profit.
new_pfs() =>
    100 - new_per(get_ctp(FP), high) >= rtp

// new_pfl returns a signal for long trades having made a profit.
new_pfl() =>
    100 - new_per(low, get_ctp(FP)) >= rtp



// -------------------------------------------------------------------------- //



// new_nst returns a signal for a new short trade. This signals the beginning of
// a trade aiming to profit from downward trends. After opening a short position
// we wait for the close short signal. Here nst means new short trade.
new_nst() =>
    hdc = has_cpd(DS) and new_dci()
    hds = has_cpd(DS)

    hdc or hds

// new_nlt returns a signal to open a long position. This signals the beginning
// of a trade aiming to profit from upward trends. After opening a long position
// we wait for the close long signal. Here sol means new long trade.
new_nlt() =>
    hdc = has_cpd(DL) and new_dci()
    hdl = has_cpd(DL)

    hdc or hdl



// -------------------------------------------------------------------------- //



if new_dci()
    res_cfc()
    res_cpc()



// -------------------------------------------------------------------------- //



new_cyc() =>
    sos = false     // Signal Open Short.
    scs = false     // Signal Close Short.
    sol = false     // Signal Open Long.
    scl = false     // Signal Close Long.

    nst = new_nst() // New Short Trade.
    nlt = new_nlt() // New Long Trade.

    lfs = new_lfs() // Loss For Short.
    pfs = new_pfs() // Profit For Short.
    lfl = new_lfl() // Loss For Long.
    pfl = new_pfl() // Profit For Long.

    cct = false     // Current Cycle Tracked.

    if emp_ccc()
        if nst
            set_ccc(OS)
            rem_ccc(CS)
            rem_ccc(OL)
            rem_ccc(CL)

            sos := true
            scs := false
            sol := false
            scl := false

            cct := true

            set_cdf("1")

        else if nlt
            rem_ccc(OS)
            rem_ccc(CS)
            set_ccc(OL)
            rem_ccc(CL)

            sos := false
            scs := false
            sol := true
            scl := false

            cct := true

            set_cdf("2")

    else
        if onl_ccc(OS)
            if pfs or lfs
                rem_ccc(OS)
                rem_ccc(CS)
                rem_ccc(OL)
                rem_ccc(CL)

                sos := false
                scs := true
                sol := false
                scl := false

                cct := true

                set_cdf("3")

        else
            if onl_ccc(OL)
                if pfl or lfl
                    rem_ccc(OS)
                    rem_ccc(CS)
                    rem_ccc(OL)
                    rem_ccc(CL)

                    sos := false
                    scs := false
                    sol := false
                    scl := true

                    cct := true

                    set_cdf("4")

    if not cct
        sos := false
        scs := false
        sol := false
        scl := false

        set_cdf("5")

    if get_cpc() > 0
        rem_ccc(OS)
        rem_ccc(CS)
        rem_ccc(OL)
        rem_ccc(CL)

        sos := false
        scs := false
        sol := false
        scl := false

        set_cdf("6")

    [sos, scs, sol, scl]


// -------------------------------------------------------------------------- //



[sos, scs, sol, scl] = new_cyc()



// -------------------------------------------------------------------------- //



// It is super important to set the last price of the current trade first. This
// allows us to calculate the profit or loss considering the sequential nature
// of pine script execution. Only after the last price is tracked and the loss
// statement is collected we can track the new first price of the next trade.
// Here lfs means loss for short. Here lfl means loss for long.



set_ctp(scs or scl ? LP : "")

lfs = scs and les_ctp() < 0 ? true : false
lfl = scl and gre_ctp() < 0 ? true : false

set_ctp(sos or sol ? FP : "")



// -------------------------------------------------------------------------- //



if lfs or lfl
    inc_cfc()

    sos := false
    sol := false

if scs or scl
    inc_cpc()

if get_cfc() >= 1 or get_cpc() > 0
    inc_cpc()

    if get_cpc() >= rpb
        res_cfc()
        res_cpc()



// -------------------------------------------------------------------------- //



// plotshape(has_cpd(DS), text="DS", location=location.belowbar, style=shape.labelup, size=size.small, color=color.purple, textcolor=color.white, transp=50)
// plotshape(has_cpd(DL), text="DL", location=location.belowbar, style=shape.labelup, size=size.small, color=color.purple, textcolor=color.white, transp=50)



// -------------------------------------------------------------------------- //



// plotshape(has_cdf( "1"), text="DEBUG  1", location=location.belowbar, style=shape.labelup, size=size.small, color=color.purple, textcolor=color.white, transp=50)
// plotshape(has_cdf( "2"), text="DEBUG  2", location=location.belowbar, style=shape.labelup, size=size.small, color=color.purple, textcolor=color.white, transp=50)
// plotshape(has_cdf( "3"), text="DEBUG  3", location=location.belowbar, style=shape.labelup, size=size.small, color=color.purple, textcolor=color.white, transp=50)
// plotshape(has_cdf( "4"), text="DEBUG  4", location=location.belowbar, style=shape.labelup, size=size.small, color=color.purple, textcolor=color.white, transp=50)
// plotshape(has_cdf( "5"), text="DEBUG  5", location=location.belowbar, style=shape.labelup, size=size.small, color=color.purple, textcolor=color.white, transp=50)
// plotshape(has_cdf( "6"), text="DEBUG  6", location=location.belowbar, style=shape.labelup, size=size.small, color=color.purple, textcolor=color.white, transp=50)
// plotshape(has_cdf( "7"), text="DEBUG  7", location=location.belowbar, style=shape.labelup, size=size.small, color=color.purple, textcolor=color.white, transp=50)
// plotshape(has_cdf( "8"), text="DEBUG  8", location=location.belowbar, style=shape.labelup, size=size.small, color=color.purple, textcolor=color.white, transp=50)



// -------------------------------------------------------------------------- //



strategy.entry(id=OS, long=false, qty=1, when=sos), strategy.exit(id=CS, from_entry=OS, limit=rtp, when=scs)
strategy.entry(id=OL, long=true,  qty=1, when=sol), strategy.exit(id=CL, from_entry=OL, limit=rtp, when=scl)
