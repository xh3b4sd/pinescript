//@version=4



// -------------------------------------------------------------------------- //



study(title="BBI, HPI, RSI", shorttitle="BBI, HPI, RSI", overlay=true)



// -------------------------------------------------------------------------- //



// new_cor returns true if the series given by ser results in true for at least
// the minimal required amount of time defined by min over a period of recent
// bars given by rec. Note that ser must be of type series[bool].
//
//     - - | | -     new_cor(ser, 2, 2) => true
//     | - - | -     new_cor(ser, 2, 5) => true
//
new_cor(ser, min, rec) =>
    cou = 0

    for i = 0 to rec
        cou := ser[i] ? cou + 1 : cou

    cou >= min

// new_crb returns true if the current bar is red, that is, the current open
// price is higher than the current close price. This signals a local downward
// movement. Here crb means current red bar.
new_crb() =>
    open > close

// new_per calculates the percentage of a fraction based on the given absolute
// value.
//
//     new_per(500, 5) => 1
//
new_per(abs, fra) =>
    fra * 100 / abs



// -------------------------------------------------------------------------- //



bbl = input(title="BBI Length", type=input.integer, defval=70,   minval=1,    step=1  )
bbs = input(title="BBI Stddev", type=input.float,   defval=2.65, minval=0.1,  step=0.1)
bbp = input(title="BBI Pivot",  type=input.float,   defval=20,   minval=0.01, step=1  )



// new_bbu returns the upper bollinger band based on the length given by bbl and
// the standard deviation given by bbs. Here bbu means bollinger band upper.
new_bbu(src, bbl, bbs) =>
    sma(src, bbl) + bbs * stdev(src, bbl)

new_bbi(src, bbl, bbs) =>
    bbu = new_bbu(src, bbl, bbs)

    cou = 0
    bac = 8

    for i = 0 to bac
        cou := high[i] > bbu[i] and bbu[i] > low[i] ? cou + 1 : cou

    new_per(bac, cou) > bbp and not (high[0] > bbu[0] and bbu[0] > low[0])



// -------------------------------------------------------------------------- //



hrb = input(title="HPI Recent Bar", type=input.integer, defval=175, minval=1, step=1)



// new_hpi returns a high price indicator for the most recent bars since hrb.
// Here hpi means high price indicator.
new_hpi(hrb) =>
    highest(open, hrb) == open and new_crb()



// -------------------------------------------------------------------------- //



// new_rsb returns the relative strength indicator for the current bar, based on
// the running moving average. Here rsb means relative strength bar.
new_rsb(src, rsl) =>
    upw = rma( max(change(src), 0), rsl)
    dow = rma(-min(change(src), 0), rsl)

    dow == 0 ? 100 : upw == 0 ? 0 : 100 - (100 / (1 + upw / dow))

// new_rsi returns the relative strength indicator for overbought price peaks.
new_rsi(src) =>
    one = new_rsb(src, 120)[1] < 57 and new_rsb(src, 120)[0] > 57
    two = new_rsb(src, 50 )[1] < 65 and new_rsb(src, 50 )[0] > 65
    thr = new_rsb(src, 30 )[1] < 70 and new_rsb(src, 30 )[0] > 70
    fou = new_rsb(src, 17 )[1] < 63 and new_rsb(src, 17 )[0] > 63

    one or two or thr or fou



// -------------------------------------------------------------------------- //



// new short trend indicator
//
// activate if
//
//     - 2 in a row
//     - 3 over 5 bars
//
new_sti() =>
    src = close

    crb = new_crb()
    bbi = new_bbi(src, bbl, bbs)
    hpi = new_hpi(hrb)
    rsi = new_rsi(src)

    bhi = (bbi[0] and hpi[0]) or (bbi[0] and hpi[1])
    bri = (bbi[0] and rsi[0]) or (bbi[0] and rsi[1])
    hri = (hpi[0] and rsi[0]) or (hpi[0] and rsi[1])

    crb and (bhi or bri or hri)



plotshape(new_sti(), text="SHORT", location=location.abovebar, style=shape.labeldown, size=size.tiny, color=color.red, textcolor=color.white, transp=0)
