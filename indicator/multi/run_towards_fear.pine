//@version=4



// -------------------------------------------------------------------------- //



study(title="RTF", shorttitle="RTF", overlay=true)



// -------------------------------------------------------------------------- //



var OS = "OS" // Open Short. The signal to start a short trade.
var CS = "CS" // Close Short. The signal to end a short trade.
var OL = "OL" // Open Long. The signal to start a long trade.
var CL = "CL" // Close Long. The signal to end a long trade.



// -------------------------------------------------------------------------- //



// Current Cycle. The cycle of the current trade. Either OS, CS, OL or CL.
var CC = array.new_string(4, "")

emp_ccc() =>
    nos = array.get(CC, 0) == ""
    ncs = array.get(CC, 1) == ""
    nol = array.get(CC, 2) == ""
    ncl = array.get(CC, 3) == ""

    nos and ncs and nol and ncl

has_ccc(v) =>
    has = false

    if v == OS
        has := array.get(CC, 0) == OS
    if v == CS
        has := array.get(CC, 1) == CS
    if v == OL
        has := array.get(CC, 2) == OL
    if v == CL
        has := array.get(CC, 3) == CL

    has

rem_ccc(v) =>
    if v == OS
        array.set(CC, 0, "")
    if v == CS
        array.set(CC, 1, "")
    if v == OL
        array.set(CC, 2, "")
    if v == CL
        array.set(CC, 3, "")

set_ccc(v) =>
    if v == OS
        array.set(CC, 0, v)
    if v == CS
        array.set(CC, 1, v)
    if v == OL
        array.set(CC, 2, v)
    if v == CL
        array.set(CC, 3, v)

// First Price. The entry price of our current trade. Based on this price we
// decide when to take profit and when to move on.
var FP = array.new_float(1, 0.0)
get_cfp() =>
    array.get(FP, 0)
set_cfp(v) =>
    array.set(FP, 0, v)



// -------------------------------------------------------------------------- //



rtp = input(title="RTF Take Profit",     type=input.float,   defval=0.4, minval=0.1, step=0.1)
hrb = input(title="HPI Recent Bar",      type=input.integer, defval=10,  minval=1,   step=1  )



// -------------------------------------------------------------------------- //



// new_per calculates the percentage of a fraction based on the given absolute
// value.
//
//     new_per(500, 5) => 1
//
new_per(abs, fra) =>
    fra * 100 / abs



// -------------------------------------------------------------------------- //



// new_hpi returns a high price indicator for the most recent bars since hrb.
// Here hpi means high price indicator.
new_hpi(hrb) =>
    highest(close, hrb) == close

// new_lpi returns a low price indicator for the most recent bars since hrb.
// Here lpi means low price indicator.
new_lpi(hrb) =>
    lowest(close, hrb) == close



// -------------------------------------------------------------------------- //



// new_cos returns a signal to open a short position. This signals the beginning
// of a trade aiming to profit from downward trends. After opening a short
// position we wait for the close short signal. Here cos means cycle open short.
new_cos() =>
    new_hpi(hrb) or new_hpi(hrb / 2)

// new_ccs returns a signal to close a short position. This signals the end of a
// trade aiming to profit from downward trends. After closing a short position
// we wait for the open long signal. Here ccs means cycle close short.
new_ccs() =>
    100 - new_per(get_cfp(), close) >= rtp

// new_col returns a signal to open a long position. This signals the beginning
// of a trade aiming to profit from upward trends. After opening a long position
// we wait for the close long signal. Here col means cycle open long.
new_col() =>
    new_lpi(hrb) or new_lpi(hrb / 2)

// new_ccl returns a signal to close a long position. This signals the end of a
// trade aiming to profit from upward trends. After closing a long position we
// wait for the open short signal. Here ccl means cycle close long.
new_ccl() =>
    100 - new_per(close, get_cfp()) >= rtp



// -------------------------------------------------------------------------- //



cos = emp_ccc() or (not has_ccc(OL) and  has_ccc(CS)                 and not has_ccc(OS) and new_cos()) ? true : false
ccs =                                   (has_ccc(OS) or has_ccc(OL)) and not has_ccc(CS) and new_ccs()  ? true : false
col =               not has_ccc(OS) and  has_ccc(CL)                 and not has_ccc(OL) and new_col()  ? true : false
ccl =                                   (has_ccc(OL) or has_ccc(OS)) and not has_ccc(CL) and new_ccl()  ? true : false



// -------------------------------------------------------------------------- //



if has_ccc(OS) and not ccs and ccl
    ccs := true
    col := true
    ccl := false

if has_ccc(OL) and not ccl and ccs
    ccl := true
    cos := true
    ccs := false



// -------------------------------------------------------------------------- //



set_ccc(cos ? OS : "")
set_ccc(ccs ? CS : "")
set_ccc(col ? OL : "")
set_ccc(ccl ? CL : "")



// -------------------------------------------------------------------------- //


rem_ccc(cos ? CS : ""), rem_ccc(cos ? CL : "")
rem_ccc(ccs ? OS : "")
rem_ccc(col ? CL : ""), rem_ccc(col ? CS : "")
rem_ccc(ccl ? OL : "")



// -------------------------------------------------------------------------- //



if cos or col
    set_cfp(close)



// -------------------------------------------------------------------------- //



plotshape(cos, text=OS, location=location.abovebar, style=shape.labeldown, size=size.small, color=color.red,   textcolor=color.white, transp=0)
plotshape(ccs, text=CS, location=location.abovebar, style=shape.labeldown, size=size.small, color=color.red,   textcolor=color.white, transp=0)
plotshape(col, text=OL, location=location.belowbar, style=shape.labelup,   size=size.small, color=color.green, textcolor=color.white, transp=0)
plotshape(ccl, text=CL, location=location.belowbar, style=shape.labelup,   size=size.small, color=color.green, textcolor=color.white, transp=0)
