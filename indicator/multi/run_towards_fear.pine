//@version=4



// -------------------------------------------------------------------------- //



study(title="RTF", shorttitle="RTF", overlay=true)



// -------------------------------------------------------------------------- //



var HR = #d32f2f // Hex Red. The red color for our color scheme indicating short trades.
var HG = #388e3c // Hex Green. The green color for our color scheme indicating long trades.



// -------------------------------------------------------------------------- //



var OS = "OS" // Open Short. The signal to start a short trade.
var CS = "CS" // Close Short. The signal to end a short trade.
var OL = "OL" // Open Long. The signal to start a long trade.
var CL = "CL" // Close Long. The signal to end a long trade.

var DS = "DS" // Direction Short. Trading to win from falling prices.
var DL = "DL" // Direction Long. Trading to win from rising prices.

var FP = "FP" // First Price. The entry price of our current trade.
var LP = "LP" // Last Price. The exit price of our current trade.



// -------------------------------------------------------------------------- //



// Current Cycle. The cycle of the current trade. Either OS, CS, OL or CL.
var CC = array.new_string(4, "")

emp_ccc() =>
    nos = array.get(CC, 0) == ""
    ncs = array.get(CC, 1) == ""
    nol = array.get(CC, 2) == ""
    ncl = array.get(CC, 3) == ""

    nos and ncs and nol and ncl

has_ccc(v) =>
    has = false

    if v == OS
        has := array.get(CC, 0) == OS
    if v == CS
        has := array.get(CC, 1) == CS
    if v == OL
        has := array.get(CC, 2) == OL
    if v == CL
        has := array.get(CC, 3) == CL

    has

onl_ccc(v) =>
    has = false

    if v == OS
        has := array.get(CC, 0) == OS and array.get(CC, 1) == "" and array.get(CC, 2) == "" and array.get(CC, 3) == ""
    if v == CS
        has := array.get(CC, 0) == "" and array.get(CC, 1) == CS and array.get(CC, 2) == "" and array.get(CC, 3) == ""
    if v == OL
        has := array.get(CC, 0) == "" and array.get(CC, 1) == "" and array.get(CC, 2) == OL and array.get(CC, 3) == ""
    if v == CL
        has := array.get(CC, 0) == "" and array.get(CC, 1) == "" and array.get(CC, 2) == "" and array.get(CC, 3) == CL

    has

rem_ccc(v) =>
    if v == OS
        array.set(CC, 0, "")
    if v == CS
        array.set(CC, 1, "")
    if v == OL
        array.set(CC, 2, "")
    if v == CL
        array.set(CC, 3, "")

set_ccc(v) =>
    if v == OS
        array.set(CC, 0, v)
    if v == CS
        array.set(CC, 1, v)
    if v == OL
        array.set(CC, 2, v)
    if v == CL
        array.set(CC, 3, v)



// -------------------------------------------------------------------------- //



// Debug Flag. Only used for development. In complex decision trees we can print
// labels based on the position the global was modified. This can help a great
// deal figuring out why a certain trade was made.
var DF = array.new_string(12, "")

has_cdf(v) =>
    has = false

    if v == "1"
        has := array.get(DF, 0) != ""
    if v == "2"
        has := array.get(DF, 1) != ""
    if v == "3"
        has := array.get(DF, 2) != ""
    if v == "4"
        has := array.get(DF, 3) != ""
    if v == "5"
        has := array.get(DF, 4) != ""
    if v == "6"
        has := array.get(DF, 5) != ""
    if v == "7"
        has := array.get(DF, 6) != ""
    if v == "8"
        has := array.get(DF, 7) != ""
    if v == "9"
        has := array.get(DF, 8) != ""
    if v == "10"
        has := array.get(DF, 9) != ""
    if v == "11"
        has := array.get(DF, 10) != ""
    if v == "12"
        has := array.get(DF, 11) != ""

    has

set_cdf(v) =>
    if v == "1"
        array.set(DF, 0, v)
    if v == "2"
        array.set(DF, 1, v)
    if v == "3"
        array.set(DF, 2, v)
    if v == "4"
        array.set(DF, 3, v)
    if v == "5"
        array.set(DF, 4, v)
    if v == "6"
        array.set(DF, 5, v)
    if v == "7"
        array.set(DF, 6, v)
    if v == "8"
        array.set(DF, 7, v)
    if v == "9"
        array.set(DF, 8, v)
    if v == "10"
        array.set(DF, 9, v)
    if v == "11"
        array.set(DF, 10, v)
    if v == "12"
        array.set(DF, 11, v)

// Note that we need to clear the array's content in order to work with a fresh
// copy on each bar when the script is executed again.
array.fill(DF, "")



// -------------------------------------------------------------------------- //



// Failure Count.
var FC = array.new_int(1, 0)

get_cfc() =>
    array.get(FC, 0)

inc_cfc() =>
    array.set(FC, 0, array.get(FC, 0) + 1)

res_cfc() =>
    array.set(FC, 0, 0)



// -------------------------------------------------------------------------- //



// Preferred Direction. This global helps to identify in which direction to
// trade next. Available constants are DS for direction short and DL for
// direction long. Note that we start out with direction short.
var PD = array.new_string(1, DS)

has_cpd(v) =>
    array.get(PD, 0) == v

set_cpd(v) =>
    if v == DS
        array.set(PD, 0, v)
    if v == DL
        array.set(PD, 0, v)



// -------------------------------------------------------------------------- //



// Trade Price. The entry price and exit price of our current trade. Based on
// these prices and their delta we decide when to take profit and when to move
// on.
var TP = array.new_float(2, 0.0)

get_ctp(v) =>
    val = 0.0

    if v == FP
        val := array.get(TP, 0)
    if v == LP
        val := array.get(TP, 1)

    val

// gre_ctp returns the trade price delta for long directional trades. If the
// result is greater zero it means the long trade made profit.
gre_ctp() =>
    array.get(TP, 1) - array.get(TP, 0)

// les_ctp returns the trade price delta for short directional trades. If the
// result is greater zero it means the short trade made profit.
les_ctp() =>
    array.get(TP, 0) - array.get(TP, 1)

set_ctp(v) =>
    if v == FP
        array.set(TP, 0, close)
    if v == LP
        array.set(TP, 1, close)



// -------------------------------------------------------------------------- //



rtp = input(title="RTF Take Profit",    type=input.float,   defval=0.3, minval=0.1, step=0.1)
rlt = input(title="RTF Loss Tolerance", type=input.float,   defval=0.9, minval=0.1, step=0.1)
hrb = input(title="HPI Recent Bar",     type=input.integer, defval=50,  minval=1,   step=1  )



// -------------------------------------------------------------------------- //



// new_per calculates the percentage of a fraction based on the given absolute
// value.
//
//     new_per(500, 5) => 1
//
new_per(abs, fra) =>
    fra * 100 / abs



// -------------------------------------------------------------------------- //



// new_hpi returns a high price indicator for the most recent bars since hrb.
// Here hpi means high price indicator.
new_hpi(hrb) =>
    highest(close, hrb) == close

// new_lpi returns a low price indicator for the most recent bars since hrb.
// Here lpi means low price indicator.
new_lpi(hrb) =>
    lowest(close, hrb) == close



// -------------------------------------------------------------------------- //



// new_pds returns true if the currently preferred trading direction is short.
// Here pds means preferred direction short.
new_pds() =>
    new_hpi(hrb * 2)

// new_pdl returns true if the currently preferred trading direction is long.
// Here pdl means preferred direction long.
new_pdl() =>
    new_lpi(hrb * 2)



// -------------------------------------------------------------------------- //



// new_cos returns a signal to open a short position. This signals the beginning
// of a trade aiming to profit from downward trends. After opening a short
// position we wait for the close short signal. Here cos means cycle open short.
new_cos() =>
    new_hpi(hrb) or new_hpi(hrb / 2)

// new_ccs returns a signal to close a short position. This signals the end of a
// trade aiming to profit from downward trends. After closing a short position
// we wait for the open long signal. Here ccs means cycle close short.
new_ccs() =>
    pro = 100 - new_per(get_ctp(FP), close) >= rtp
    los = 100 - new_per(close, get_ctp(FP)) >= rlt

    pro or los

// new_col returns a signal to open a long position. This signals the beginning
// of a trade aiming to profit from upward trends. After opening a long position
// we wait for the close long signal. Here col means cycle open long.
new_col() =>
    new_lpi(hrb) or new_lpi(hrb / 2)

// new_ccl returns a signal to close a long position. This signals the end of a
// trade aiming to profit from upward trends. After closing a long position we
// wait for the open short signal. Here ccl means cycle close long.
new_ccl() =>
    pro = 100 - new_per(close, get_ctp(FP)) >= rtp
    los = 100 - new_per(get_ctp(FP), close) >= rlt

    pro or los



// -------------------------------------------------------------------------- //



new_cyc() =>
    cos = new_cos()
    ccs = new_ccs()
    col = new_col()
    ccl = new_ccl()

    cct = false // Constant Cycle Tracked.

    if emp_ccc()
        if cos
            set_ccc(OS)
            rem_ccc(CS)
            rem_ccc(OL)
            rem_ccc(CL)

            cos := true
            ccs := false
            col := false
            ccl := false

            cct := true

            set_cdf("1")

    else
        if onl_ccc(OS)
            if ccs and not ccl // success short trade
                set_ccc(OS)
                rem_ccc(CS)
                rem_ccc(OL)
                rem_ccc(CL)

                cos := true
                ccs := true
                col := false
                ccl := false

                cct := true

                set_cdf("2")

            else if ccs and ccl // failure short trade
                if has_cpd(DS)
                    set_ccc(OS)
                    rem_ccc(CS)
                    rem_ccc(OL)
                    rem_ccc(CL)

                    cos := true
                    ccs := true
                    col := false
                    ccl := false

                    cct := true

                    set_cdf("3")

                else if has_cpd(DL)
                    rem_ccc(OS)
                    rem_ccc(CS)
                    set_ccc(OL)
                    rem_ccc(CL)

                    cos := false
                    ccs := true
                    col := true
                    ccl := false

                    cct := true

                    set_cdf("4")

        else
            if onl_ccc(CS)
                if cos or col
                    if has_cpd(DS)
                        set_ccc(OS)
                        rem_ccc(CS)
                        rem_ccc(OL)
                        rem_ccc(CL)

                        cos := true
                        ccs := false
                        col := false
                        ccl := false

                        cct := true

                        set_cdf("5")

                    else if has_cpd(DL)
                        rem_ccc(OS)
                        rem_ccc(CS)
                        set_ccc(OL)
                        rem_ccc(CL)

                        cos := false
                        ccs := false
                        col := true
                        ccl := false

                        cct := true

                        set_cdf("6")

            else
                if onl_ccc(OL)
                    if ccl and not ccs // success long trade
                        rem_ccc(OS)
                        rem_ccc(CS)
                        set_ccc(OL)
                        rem_ccc(CL)

                        cos := false
                        ccs := false
                        col := true
                        ccl := true

                        cct := true

                        set_cdf("7")

                    if ccl and ccs // failure long trade
                        if has_cpd(DS)
                            set_ccc(OS)
                            rem_ccc(CS)
                            rem_ccc(OL)
                            rem_ccc(CL)

                            cos := true
                            ccs := false
                            col := false
                            ccl := true

                            cct := true

                            set_cdf("8")

                        else if has_cpd(DL)
                            rem_ccc(OS)
                            rem_ccc(CS)
                            set_ccc(OL)
                            rem_ccc(CL)

                            cos := false
                            ccs := false
                            col := true
                            ccl := true

                            cct := true

                            set_cdf("9")

                else
                    if onl_ccc(CL)
                        if cos or col
                            if has_cpd(DS)
                                set_ccc(OS)
                                rem_ccc(CS)
                                rem_ccc(OL)
                                rem_ccc(CL)

                                cos := true
                                ccs := false
                                col := false
                                ccl := false

                                cct := true

                                set_cdf("10")

                            else if has_cpd(DL)
                                rem_ccc(OS)
                                rem_ccc(CS)
                                set_ccc(OL)
                                rem_ccc(CL)

                                cos := false
                                ccs := false
                                col := true
                                ccl := false

                                cct := true

                                set_cdf("11")

    if not cct
        cos := false
        ccs := false
        col := false
        ccl := false

        set_cdf("12")

    [cos, ccs, col, ccl]


// -------------------------------------------------------------------------- //



[cos, ccs, col, ccl] = new_cyc()



// -------------------------------------------------------------------------- //



// It is super important to set the last price of the current trade first. This
// allows us to calculate the profit or loss considering the sequential nature
// of pine script execution. Only after the last price is tracked and the loss
// statement is collected we can track the new first price of the next trade.
// Here ffs means failure for short. Here ffl means failure for long.



set_ctp(ccs or ccl ? LP : "")

ffs = ccs and les_ctp() < 0 ? true : false
ffl = ccl and gre_ctp() < 0 ? true : false

set_ctp(cos or col ? FP : "")



// -------------------------------------------------------------------------- //



// Here we make intentional direction changes in order to make better trade
// decisions. That means to trade with the trend. At first we have an access
// point for custom logic to dictate the trade direction. If this first attempt
// fails we flip the direction. After the flip all trades should continue short
// or long until a trade fails again. Only after this additional failure we
// reset the failure count and start over with dynamic decision making.

pds = new_pds()
pdl = new_pdl()

if ffs or ffl
    inc_cfc()

    if get_cfc() == 0
        set_cpd(pds ? DS : "")
        set_cpd(pdl ? DL : "")

    if get_cfc() == 1
        if has_cpd(DL)
            set_cpd(DS)

        else if has_cpd(DS)
            set_cpd(DL)

    if get_cfc() >= 2
        res_cfc()



// -------------------------------------------------------------------------- //



// plotshape(has_ccc(OS), text="DEBUG OS", location=location.belowbar, style=shape.labelup, size=size.small, color=color.purple, textcolor=color.white, transp=50)
// plotshape(has_ccc(CS), text="DEBUG CS", location=location.belowbar, style=shape.labelup, size=size.small, color=color.purple, textcolor=color.white, transp=50)
// plotshape(has_ccc(OL), text="DEBUG OL", location=location.belowbar, style=shape.labelup, size=size.small, color=color.purple, textcolor=color.white, transp=50)
// plotshape(has_ccc(CL), text="DEBUG CL", location=location.belowbar, style=shape.labelup, size=size.small, color=color.purple, textcolor=color.white, transp=50)



// -------------------------------------------------------------------------- //



// plotshape(has_cdf( "1"), text="DEBUG  1", location=location.belowbar, style=shape.labelup, size=size.small, color=color.purple, textcolor=color.white, transp=50)
// plotshape(has_cdf( "2"), text="DEBUG  2", location=location.belowbar, style=shape.labelup, size=size.small, color=color.purple, textcolor=color.white, transp=50)
// plotshape(has_cdf( "3"), text="DEBUG  3", location=location.belowbar, style=shape.labelup, size=size.small, color=color.purple, textcolor=color.white, transp=50)
// plotshape(has_cdf( "4"), text="DEBUG  4", location=location.belowbar, style=shape.labelup, size=size.small, color=color.purple, textcolor=color.white, transp=50)
// plotshape(has_cdf( "5"), text="DEBUG  5", location=location.belowbar, style=shape.labelup, size=size.small, color=color.purple, textcolor=color.white, transp=50)
// plotshape(has_cdf( "6"), text="DEBUG  6", location=location.belowbar, style=shape.labelup, size=size.small, color=color.purple, textcolor=color.white, transp=50)
// plotshape(has_cdf( "7"), text="DEBUG  7", location=location.belowbar, style=shape.labelup, size=size.small, color=color.purple, textcolor=color.white, transp=50)
// plotshape(has_cdf( "8"), text="DEBUG  8", location=location.belowbar, style=shape.labelup, size=size.small, color=color.purple, textcolor=color.white, transp=50)
// plotshape(has_cdf( "9"), text="DEBUG  9", location=location.belowbar, style=shape.labelup, size=size.small, color=color.purple, textcolor=color.white, transp=50)
// plotshape(has_cdf("10"), text="DEBUG 10", location=location.belowbar, style=shape.labelup, size=size.small, color=color.purple, textcolor=color.white, transp=50)
// plotshape(has_cdf("11"), text="DEBUG 11", location=location.belowbar, style=shape.labelup, size=size.small, color=color.purple, textcolor=color.white, transp=50)
// plotshape(has_cdf("12"), text="DEBUG 12", location=location.belowbar, style=shape.labelup, size=size.small, color=color.purple, textcolor=color.white, transp=50)



// -------------------------------------------------------------------------- //



plotshape(cos,             text=OS, location=location.abovebar, style=shape.circle, size=size.tiny, color=HR, textcolor=color.white, transp=30)
plotshape(ccs and not ffs, text=CS, location=location.belowbar, style=shape.circle, size=size.tiny, color=HR, textcolor=color.white, transp=30)
plotshape(ccs and     ffs, text=CS, location=location.belowbar, style=shape.xcross, size=size.tiny, color=HR, textcolor=color.white, transp=30)
plotshape(col,             text=OL, location=location.abovebar, style=shape.circle, size=size.tiny, color=HG, textcolor=color.white, transp=30)
plotshape(ccl and not ffl, text=CL, location=location.belowbar, style=shape.circle, size=size.tiny, color=HG, textcolor=color.white, transp=30)
plotshape(ccl and     ffl, text=CL, location=location.belowbar, style=shape.xcross, size=size.tiny, color=HG, textcolor=color.white, transp=30)
